"""A module that allow exporting an openalea node/factory as an IPM model"""
import json
import inspect
import subprocess
import psutil
import os
# check that modules required to launch webservice are there
import fastapi
import uvicorn
import openalea.core

def oa_type(interface):
    """Openalea.core interface, without the I and lowercase"""
    return str(interface)[1:].lower()

# mapping of openalea types to pydantic (python) types
def py_type(oa_type):
    py_types = {'sequence': 'list',
                'filestr': 'str',
                'dirstr': 'str',
                'textstr': 'str',
                'codestr': 'str',
                }
    return py_types.get(oa_type, oa_type)

# mapping of py_types to json schema types
json_type={'str': 'string',
              'float': 'number',
              'int': 'integer',
              'dict': 'object',
              'list': 'array',
               'tuple': 'array',
              'bool': 'boolean',
              None: 'null'}

#mappping of json types to pydantic types
pydantic_type={'string': 'str',
              'number': 'float',
              'integer': 'int',
              'object': 'dict',
              'array': 'list',
              'boolean': 'bool',
              'null': None}



pydantic_parameter_template="""
    {name}: {type}"""

pydantic_template="""from __future__ import annotations

from typing import List

from pydantic import BaseModel


class ConfigParameters(BaseModel):{config_params}


class LocationWeatherDatum(BaseModel):
    longitude: float
    latitude: float
    altitude: float
    data: List[List[float]]
    length: int
    width: int


class WeatherData(BaseModel):
    timeStart: str
    timeEnd: str
    interval: int
    weatherParameters: List[int]
    locationWeatherData: List[LocationWeatherDatum]


class PydanticModel(BaseModel):
    modelId: str
    configParameters: ConfigParameters
    weatherData: WeatherData
"""

fastAPI_template="""{pydantic_model}

from fastapi import FastAPI
from openalea.dss.dss_factory import encode_input

app = FastAPI()

from openalea.core.node import FuncNode
from openalea.core import IFloat, IInt

{model_source}

inputs = {inputs}
outputs = {outputs}
node = FuncNode(inputs, outputs, {model_name})
node.name='{model_id}'


input_mapping = {input_mapping}

@app.post("/{model_id}/")
async def model_evaluation(data: PydanticModel):
    input_data = data.dict()
    inputs = encode_input(node, input_data, input_mapping)
    return [node(input) for input in inputs]
"""

def wrap_meta_informations(id='MODEL',
                           name='Sample model',
                           version = '0.0.0',
                           purpose = 'Sample meta informations generated by openalea dss facctory',
                           description= 'Please provide here a concise description of the model',
                           type_of_decision='Short-term tactical',
                           type_of_output='Risk indication',
                           description_url=None,
                           citation=None,
                           keywords=None,
                           platform_validated=False,
                           pests=None,
                           crops=None,
                           author_names=None,
                           author_emails=None,
                           author_organizations=None,
                           valid_spatial=None):
    if pests is None:
        pests=[]
    if crops is None :
        crops=[]
    if author_names is None:
        author_names = ['Anonymous']
    if author_emails is None:
        author_emails = ['anonymous@mail'] * len(author_names)
    if author_organizations is None:
        author_organizations = ['Unknown'] * len(author_names)
    authors = [{'name':name,'email':mail, 'organization':org}
               for name, mail, org in zip(author_names, author_emails,author_organizations)]
    if valid_spatial is None:
        valid_spatial = {'countries': [], 'geoJSON': '{}'}

    return dict(id=id, name=name, version=version,purpose=purpose,
                description=description, type_of_decision=type_of_decision,
                type_of_output=type_of_output, description_url=description_url,
                citation=citation, keywords=keywords,platform_validated=platform_validated,
                pests=pests,crops=crops, authors=authors, valid_spatial=valid_spatial)


def wrap_input_schema(model_id, input_desc, weather_parameters, parameters):
    input_schema = {
        'type': 'object',
        'properties': {
            'configParameters': {
                'title': 'Configuration parameters',
                'type': 'object',
                'properties': {},
                'required': []
            },
        },
        'required': ['modelId', 'configParameters']
    }

    properties = input_schema['properties']
    properties['modelId'] = {'title': 'Model_Id',
                             'type': 'string',
                             'pattern': '^%s$' % (model_id),
                             'default': model_id,
                             'description': 'Must be %s' % (model_id)
                             }

    config = properties['configParameters']['properties']

    if weather_parameters is not None:
        properties['weatherData'] = {'$ref': 'https://platform.ipmdecisions.net/api/wx/rest/schema/weatherdata'}
        input_schema['required'].append('weatherData')
        config['timeZone'] = {'type': 'string',
                              'title': 'Time zone (e.g. Europe/Oslo)',
                              'default': 'Europe/Oslo',
                              'options': {
                                  'infoText': 'The time zone information is used when hourly temperature values need to be converted to daily.'}
                              }
        config['timeStart'] = {'type': 'string',
                               'format': 'date',
                               'default': '{CURRENT_YEAR}-03-01',
                               'title': 'Start date of calculation (YYYY-MM-DD)'}
        config['timeEnd'] = {'type': 'string',
                             'format': 'date',
                             'default': '{CURRENT_YEAR}-09-01',
                             'title': 'End date of calculation (YYYY-MM-DD)'}
        properties['configParameters']['required'] = ['timeZone', 'timeStart', 'timeEnd']

    if parameters is not None:
        inputs = {}
        node_ports = {port['name']: port for port in input_desc}
        for p in parameters:
            port = node_ports[p]
            d = dict(default=port['value'])
            oat = oa_type(port['interface'])
            if oat == 'datetime':
                d['format'] = 'date-time'
            d['type'] = json_type[py_type(oat)]
            inputs[p] = d
        config.update(inputs)

    properties['configParameters']['properties'] = config
    properties['configParameters']['required'] = list(config.keys())

    return input_schema


def encode_input(node, input_data, input_mapping):
    inputs={}
    length = input_data['weatherData']['locationWeatherData'][0]['length']
    for p in input_mapping['config_params']:
        inputs[p] = [input_data['configParameters'].get(p,0)] * length
    wdata = dict(zip(input_data['weatherData']['weatherParameters'],zip(*input_data['weatherData']['locationWeatherData'][0]['data'])))
    for p, p_code in input_mapping['weather_parameters'].items():
        inputs[p] = wdata[p_code]
    return list(zip(*[inputs[port['name']] for port in node.input_desc]))

def wrap_outputs(node, decision_support=None):
    if decision_support is None:
        decision_support = 'None'
    def _ipm_port(port):
        return dict(id=port['name'])

    output = dict(warning_status_interpretation =decision_support,
                result_parameters = [_ipm_port(p) for p in node.output_desc])
    return output


def dss_factory(node, interval=86400, weather_parameters=None, parameters=None, decision_support=None, meta=None):
    """Transform an openalea node in a IPM model json descriptor and generate a fastAPI script to launch webservice

    Args:
        node: the node to be exported
        interval: the time step of the model (s)
        weather_parameters: a mapping between node input name and weather data codes, if any.
        None if none of the input is a weather data
        parameters: a list of node input name to be exposed as config parameters in IPM-Decison platform
        meta : model meta informations
    Returns:
        model: a json-like dict describing the model
        dss_service: a string containing the script to be run for launching the web service

    """

    model_id = node.name

    if meta is None:
        meta = wrap_meta_informations(id=model_id)
    model = meta.copy()

    execution = dict(type='ONTHEFLY',
                     endpoint=f'http://127.0.0.1:8000/{model_id}/',
                     form_method='post',
                     content_type='application/json',
                     input_schema_categories={'hidden': ['modelId'],
                                              'system': [],
                                              'user_init': [],
                                              'triggered': [],
                                              'internal': []})

    execution['input_schema'] = wrap_input_schema(model_id, node.input_desc,
                                                  weather_parameters, parameters)
    model['execution'] = execution

    input = {'weather_parameters': None,
             'field_observation': None,
             'weather_data_period_start':None,
             'weather_data_period_end':None}

    if weather_parameters is not None:
        input['weather_parameters'] = [{'parameter_code': v, 'interval': interval} for v in weather_parameters.values()]
        input['weather_data_period_start'] = [{'determined_by': 'INPUT_SCHEMA_PROPERTY',
                                               'value': 'configParameters.timeStart'}]
        input['weather_data_period_end'] = [{'determined_by': 'INPUT_SCHEMA_PROPERTY',
                                             'value': 'configParameters.timeEnd'}]
    model['input'] = input

    model['output'] = wrap_outputs(node, decision_support=decision_support)

    config = execution['input_schema']['properties']['configParameters']['properties']
    config_params = ''.join([pydantic_parameter_template.format(name=k, type=pydantic_type[v['type']]) for k,v in config.items()])
    pydantic_model = pydantic_template.format(config_params=config_params)
    input_mapping = "{'weather_parameters': %s, 'config_params': %s}"%(json.dumps(weather_parameters),json.dumps(parameters))
    dss_service = fastAPI_template.format(model_source=inspect.getsource(node.func),
                                          model_name= node.func.__name__,
                                          pydantic_model=pydantic_model,
                                          model_id=model_id,
                                          input_mapping=input_mapping,
                                          inputs=node.input_desc,
                                          outputs=node.output_desc)
    return model, dss_service


def start_service(dss_service):
    """Launch a uvicorn-fastapi webservice"""
    with open('main.py', 'w') as outfile:
        outfile.write(dss_service)
    pro = subprocess.Popen('uvicorn main:app', stdout=subprocess.PIPE,
                           shell=True)
    return 'http://127.0.0.1:8000', pro



def stop_service(proc, including_parent=True):
    parent = psutil.Process(proc.pid)
    children = parent.children(recursive=True)
    for child in children:
        child.kill()
    gone, still_alive = psutil.wait_procs(children, timeout=5)
    if including_parent:
        try:
            parent.kill()
            parent.wait(5)
        except:
            pass
    os.remove('main.py')